from auturuns import AutoRun
import win32security
import subprocess
import os


class Technics(object):

    def __init__(self,report,main=False):
        self.jsonlist = report
        self.runsfiles = AutoRun(main).runsFiles

    def isDllExist(self,name):
        global TESTEDLL
        try:
            TESTEDLL
        except: TESTEDLL = {}
        if not name in list(TESTEDLL.keys()): 
            for i in os.environ["path"].split(";"):
                TESTEDLL[name] = False
                if os.path.isdir(i): files = os.listdir(i)
                else: continue
                if name in files or name.lower() in files:
                    TESTEDLL[name] = True
                    break
        return TESTEDLL[name]


    def isPermited(self,filename):
        try:
            dacl = win32security.GetFileSecurity(filename, win32security.DACL_SECURITY_INFORMATION).GetSecurityDescriptorDacl()
            ace_count = dacl.GetAceCount()
            users = ["BUILTIN\\Users",os.environ['USERDOMAIN']+'\\'+os.environ['USERNAME']]
            for i in range(0, ace_count):
                try:
                    _, access, usersid = dacl.GetAce(i)
                    user, group, _  = win32security.LookupAccountSid('', usersid)
                    user = group+'\\'+user
                    isperm = [-536805376,2032127]
                    if user in users and access in isperm:
                        return True
                except:
                    pass
        except:
            pass
        return False

    def isPersistence(self,jsonData):
        for i in self.runsfiles:
            if jsonData['Process_Name']['$'] in i:
                return True
        return False


    def isSystem(self,jsonData):
        if ("C:\\windows" in jsonData['Path']['$'] 
            or "c:\\windows" in jsonData['Path']['$'] 
            or "C:\\Windows" in jsonData['Path']['$'] 
            or "c:\\Windows"in jsonData['Path']['$']
            or "C:\\WINDOWS" in jsonData['Path']['$']
        ):
            return False
        if ("Program" in jsonData['Path']['$'] 
            and self.isPermited(os.path.dirname(jsonData['Path']['$']))
            and jsonData['User']["$"]!=os.environ['USERDOMAIN']+'\\'+os.environ['USERNAME']
        ):
            return True
        if "Program" in jsonData['Path']['$']:
            return False
        return jsonData['User']["$"]!=os.environ['USERDOMAIN']+'\\'+os.environ['USERNAME']

    def isproxing(self,jsonData):
        if (self.isPermited(os.path.split(jsonData['Path']['$'])[0])
            and self.isDllExist(os.path.split(jsonData['Path']['$'])[-1]) 
        or (os.path.isfile(jsonData['Path']['$'])
            and self.isPermited(os.path.split(jsonData['Path']['$'])[0]))):
            return True
        return False

    def isoneClick(self,jsonData):
        if (os.path.join(os.path.expanduser("~"), "Downloads") 
        in os.path.dirname(jsonData['Path']['$'])
        ):
            return True
        
    def isCanElevet(self,tech,technics):
        return technics[1] in tech and technics[2] in tech
        

    def genResult(self,result,res,process,tech):
        dllName = list(res.keys())[0]
    #     print(process)
        if process not in list(result.keys()):
            result[process]={
                dllName:{
                    "User": res[dllName]["User"],
                    "Technics": ", ".join(tech),
                    "DllPath": res[dllName]["DllPath"]
                }
            }
            return result
            
        resultkeys = list(result[process].keys())
        if dllName not in resultkeys:
            result[process][dllName] = {
                "User": res[dllName]["User"],
                "Technics": ", ".join(res[dllName]["Technics"]),
                "DllPath": res[dllName]["DllPath"]
            }
            return result
        if dllName in resultkeys and res[dllName]["DllPath"] not in result[process][dllName]["DllPath"]:
            try:
                result[process][dllName]["DllPath"]+=", "+res[dllName]["DllPath"]
            except:
                pass
        if 'NT AUTHORITY' not in result[process][dllName]["User"]:
            result[process][dllName]["User"] = res[dllName]["User"]
            if res[dllName]["DllPath"] not in result[process][dllName]["DllPath"]:
                result[process][dllName]["DllPath"] += ", "+res[dllName]["DllPath"]
                
        for i in res[dllName]["Technics"]:
            if i not in result[process][dllName]["Technics"]:
                result[process][dllName]["Technics"]+=", "+i 
        if res[dllName]["DllPath"] not in result[process][dllName]["DllPath"]:
            result[process][dllName]["DllPath"] += ", "+res[dllName]["DllPath"]
        return result
            
        

    def analyse(self):
        result = {}
        technics = {
            1: "Privilege escalation",
            2: "Persistence",
            3: "Elevetion of Priviledge",
            4: "One click Attack",
            5: "Dll injection",
            6: "Dll hijacking proxing"
        }
        for i in self.jsonlist:
    #         print(1)
            tech = [technics[5]]
            if self.isSystem(i):
                tech.append(technics[1])
            if self.isPersistence(i):
                tech.append(technics[2])
            if self.isproxing(i):
                tech.append(technics[6])
            if self.isoneClick(i):
                tech.append(technics[4])
            if self.isCanElevet(tech,technics):
                tech.append(technics[3])
            
            
            res = {os.path.split(i['Path']['$'])[-1]: {
                        "User": i['User']["$"],
                        "Technics": tech,
                        "DllPath": i['Path']['$']
                    }
                }
            result = self.genResult(
                result,
                res,
                i['Process_Name']["$"],
                tech
            )
        return result










def cmd(self,command,byline=False):
    if byline:
        return [i.decode(errors="replace").strip() for i in subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout.readlines()]
    return subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout.read().decode(errors='replace').strip()

        

def findaccesspathenv(self):
    return [i for i in os.environ["path"].split(";") if self.isPermited(i)]